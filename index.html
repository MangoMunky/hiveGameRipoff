<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Hex Duel V4 - Multi-Touch & Pass</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-color: #16213e;
            --text-color: #e94560;
            --highlight: #0f3460;
            --accent: #4cd137;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI LAYOUT */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            background: rgba(22, 33, 62, 0.95);
            padding: 10px;
            pointer-events: auto;
            border: 1px solid var(--highlight);
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        button {
            background: var(--text-color);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
        }
        button:active { transform: scale(0.95); }
        button.secondary { background: var(--highlight); border: 1px solid var(--text-color); }

        #bottom-bar {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 20px;
            max-height: 40vh;
            z-index: 30;
        }

        #hand-container {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 10px 20px;
            justify-content: flex-start; 
            -webkit-overflow-scrolling: touch;
            pointer-events: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--text-color) transparent;
        }
        
        @media (min-width: 800px) {
            #hand-container {
                justify-content: center;
            }
        }
        
        #hand-container::-webkit-scrollbar { height: 4px; }
        #hand-container::-webkit-scrollbar-thumb { background: var(--text-color); border-radius: 10px; }

        .hand-piece {
            min-width: 68px;
            height: 90px;
            background: #252a34;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 2px solid transparent;
            user-select: none;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .hand-piece.selected {
            border-color: var(--text-color);
            background: #2a2a40;
            transform: translateY(-5px);
        }

        .piece-icon { font-size: 28px; margin-bottom: 2px; }
        .piece-name { font-size: 10px; font-weight: bold; color: #fff; margin-bottom: 2px; }
        .piece-count { font-size: 10px; color: #aaa; }

        #stack-inspector {
            position: absolute;
            bottom: 140px; 
            left: 10px;
            background: rgba(0,0,0,0.95);
            border: 1px solid var(--text-color);
            border-radius: 8px;
            padding: 10px;
            display: none;
            pointer-events: auto;
            min-width: 160px;
            z-index: 220;
        }
        .stack-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            border-bottom: 1px solid #333;
            font-size: 0.9rem;
        }
        .stack-level { color: #aaa; font-size: 0.8rem; width: 20px; }

        #message-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(22, 33, 62, 0.98);
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            display: none;
            pointer-events: auto;
            border: 2px solid var(--text-color);
            z-index: 500;
        }

        #legend-panel {
            position: absolute;
            top: 60px;
            right: 10px;
            width: 90%;
            max-width: 360px;
            max-height: 70vh;
            overflow-y: auto;
            background: rgba(22, 33, 62, 0.98);
            border: 1px solid var(--highlight);
            border-radius: 8px;
            padding: 15px;
            pointer-events: auto;
            display: none;
            z-index: 400;
        }
        .legend-item { margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .legend-title { font-weight: bold; color: var(--text-color); display: flex; align-items: center; gap: 10px; }
        .legend-desc { font-size: 0.85em; color: #ccc; margin-top: 4px; line-height: 1.4; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="top-bar" class="hud-panel">
            <div>Turn: <span id="turn-indicator" style="font-weight:bold; color: #fff;">White</span></div>
            <div style="display:flex; gap:10px;">
                <button class="secondary" onclick="game.passTurn()">Pass</button>
                <button onclick="toggleLegend()">Rules</button>
                <button onclick="game.resetGame()">Restart</button>
            </div>
        </div>
        
        <div id="stack-inspector">
            <div style="font-size:0.8rem; color:#aaa; margin-bottom:5px;">Stack Contents</div>
            <div id="stack-list"></div>
        </div>

        <div id="message-area">
            <h2 id="win-msg" style="margin-top:0;">Game Over</h2>
            <button onclick="game.resetGame()">New Game</button>
        </div>

        <div id="legend-panel">
            <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                <h3 style="margin:0;">Unit Guide</h3>
                <button onclick="toggleLegend()" style="padding:2px 8px; font-size:12px;">X</button>
            </div>
            <div class="legend-item"><div class="legend-title"><span>ü¶Ä</span> Crab</div><div class="legend-desc">Your King. Moves 1 space. You lose if surrounded.</div></div>
            <div class="legend-item"><div class="legend-title"><span>ü¶ê</span> Shrimp</div><div class="legend-desc">Slides exactly 3 spaces around the circumference.</div></div>
            <div class="legend-item"><div class="legend-title"><span>ü¶à</span> Shark</div><div class="legend-desc">Slides any distance along the edge.</div></div>
            <div class="legend-item"><div class="legend-title"><span>üê¨</span> Dolphin</div><div class="legend-desc">Jumps over pieces to the first empty spot.</div></div>
            <div class="legend-item"><div class="legend-title"><span>ü¶Ü</span> Duck</div><div class="legend-desc">Exactly 3 steps: Up, Across, Down. Land on empty space.</div></div>
            <div class="legend-item"><div class="legend-title"><span>ü¶û</span> Lobster</div><div class="legend-desc">Moves 1 space. Can lift neighbors onto itself.</div></div>
            <div class="legend-item"><div class="legend-title"><span>‚≠ê</span> Starfish</div><div class="legend-desc">Moves 1 space. Can climb on top of stacks.</div></div>
            <div class="legend-item"><div class="legend-title"><span>üêô</span> Octopus</div><div class="legend-desc">Mimics abilities of adjacent units (excluding Rocks).</div></div>
        </div>

        <div id="bottom-bar" class="hud-panel">
            <div id="hand-container"></div>
        </div>
    </div>
</div>

<script>
function toggleLegend() {
    const p = document.getElementById('legend-panel');
    p.style.display = p.style.display === 'block' ? 'none' : 'block';
}

const BASE_HEX_SIZE = 40;
let HEX_SIZE = BASE_HEX_SIZE;

const DIRECTIONS = [
    {q: 1, r: 0}, {q: 0, r: 1}, {q: -1, r: 1},
    {q: -1, r: 0}, {q: 0, r: -1}, {q: 1, r: -1}
];

class Hex {
    constructor(q, r) { this.q = q; this.r = r; }
    toString() { return `${this.q},${this.r}`; }
    static fromString(s) { const p = s.split(','); return new Hex(parseInt(p[0]), parseInt(p[1])); }
    add(h) { return new Hex(this.q + h.q, this.r + h.r); }
    equals(h) { return this.q === h.q && this.r === h.r; }
}

function hexToPixel(hex) {
    const x = HEX_SIZE * (3/2 * hex.q);
    const y = HEX_SIZE * Math.sqrt(3) * (hex.r + hex.q/2);
    return {x, y};
}

function pixelToHex(x, y) {
    const q = (2/3 * x) / HEX_SIZE;
    const r = (-1/3 * x + Math.sqrt(3)/3 * y) / HEX_SIZE;
    return hexRound(q, r);
}

function hexRound(q, r) {
    let s = -q - r;
    let rq = Math.round(q);
    let rr = Math.round(r);
    let rs = Math.round(s);
    if (Math.abs(rq - q) > Math.abs(rr - r) && Math.abs(rq - q) > Math.abs(rs - s)) rq = -rr - rs;
    else if (Math.abs(rr - r) > Math.abs(rs - s)) rr = -rq - rs;
    return new Hex(rq, rr);
}

function getNeighbors(hex) { return DIRECTIONS.map(d => hex.add(d)); }

const PIECES = {
    CRAB: 'Crab',
    SHRIMP: 'Shrimp',
    SHARK: 'Shark',
    DOLPHIN: 'Dolphin',
    DUCK: 'Duck',
    LOBSTER: 'Lobster',
    STARFISH: 'Starfish',
    OCTOPUS: 'Octopus',
    ROCK: 'Rock'
};

const PIECE_CONFIG = {
    [PIECES.CRAB]: { icon: 'ü¶Ä', color: '#ff6b6b' },
    [PIECES.SHRIMP]: { icon: 'ü¶ê', color: '#ff9ff3' },
    [PIECES.SHARK]: { icon: 'ü¶à', color: '#54a0ff' },
    [PIECES.DOLPHIN]: { icon: 'üê¨', color: '#00d2d3' },
    [PIECES.DUCK]: { icon: 'ü¶Ü', color: '#1dd1a1' },
    [PIECES.LOBSTER]: { icon: 'ü¶û', color: '#e55039' },
    [PIECES.STARFISH]: { icon: '‚≠ê', color: '#feca57' },
    [PIECES.OCTOPUS]: { icon: 'üêô', color: '#c8d6e5' },
    [PIECES.ROCK]: { icon: 'ü™®', color: '#636e72' }
};

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.board = new Map(); 
        this.turn = 'white';
        this.selectedHex = null;
        this.selectedHandPiece = null;
        this.validMoves = [];
        this.liftTargets = [];
        this.gameOver = false;
        this.passCount = 0; // Tracks consecutive passes
        
        this.hands = { white: {}, black: {} };

        this.camera = { x: 0, y: 0, zoom: 1.0 };
        this.lastMouse = { x: 0, y: 0 };
        this.isDragging = false;
        
        // Touch state
        this.touches = {};
        this.initialPinchDist = null;
        this.initialZoom = 1.0;

        this.setupInputs();
        this.resetGame();
        requestAnimationFrame(() => this.loop());
    }

    resetGame() {
        this.board.clear();
        this.turn = 'white';
        this.gameOver = false;
        this.selectedHex = null;
        this.selectedHandPiece = null;
        this.validMoves = [];
        this.liftTargets = [];
        this.passCount = 0;

        // Reset pieces count
        const startHand = { 
            [PIECES.SHRIMP]: 3, 
            [PIECES.SHARK]: 2, 
            [PIECES.DOLPHIN]: 2, 
            [PIECES.DUCK]: 2, 
            [PIECES.LOBSTER]: 1, 
            [PIECES.STARFISH]: 1, 
            [PIECES.OCTOPUS]: 1 
        };
        this.hands.white = { ...startHand };
        this.hands.black = { ...startHand };

        this.camera = { x: 0, y: 0, zoom: 1.0 };

        document.getElementById('message-area').style.display = 'none';
        document.getElementById('stack-inspector').style.display = 'none';

        this.placePiece(new Hex(0, 0), PIECES.ROCK, 'neutral');
        this.placePiece(new Hex(0, -1), PIECES.CRAB, 'white');
        this.placePiece(new Hex(0, 1), PIECES.CRAB, 'black');

        this.updateUI();
    }

    placePiece(hex, type, color) {
        const key = hex.toString();
        if (!this.board.has(key)) this.board.set(key, []);
        this.board.get(key).push({ type, color });
    }

    getTopPiece(hex) {
        const stack = this.board.get(hex.toString());
        return (stack && stack.length > 0) ? stack[stack.length - 1] : null;
    }

    getHeight(hex) {
        const stack = this.board.get(hex.toString());
        return stack ? stack.length : 0;
    }

    getAllOccupiedHexes() { return Array.from(this.board.keys()).map(Hex.fromString); }

    passTurn() {
        if (this.gameOver) return;
        this.passCount++;
        if (this.passCount >= 2) {
            this.endGame("Draw by Agreement (Two Passes)");
        } else {
            this.switchTurn(true);
        }
    }

    switchTurn(isPass = false) {
        if (!isPass) this.passCount = 0;
        this.turn = this.turn === 'white' ? 'black' : 'white';
        this.selectedHex = null;
        this.selectedHandPiece = null;
        this.validMoves = [];
        this.liftTargets = [];
        this.checkWinCondition();
        this.updateUI();
    }

    checkWinCondition() {
        let whiteDead = false, blackDead = false;
        for (const [key, stack] of this.board) {
            const crab = stack.find(p => p.type === PIECES.CRAB);
            if (crab) {
                const neighbors = getNeighbors(Hex.fromString(key));
                const walled = neighbors.filter(n => this.board.has(n.toString())).length === 6;
                if (walled) {
                    if (crab.color === 'white') whiteDead = true;
                    else blackDead = true;
                }
            }
        }
        if (whiteDead && blackDead) this.endGame("Draw!");
        else if (whiteDead) this.endGame("Black Wins!");
        else if (blackDead) this.endGame("White Wins!");
    }

    endGame(msg) {
        this.gameOver = true;
        document.getElementById('win-msg').innerText = msg;
        document.getElementById('message-area').style.display = 'block';
    }

    checkOneHive(startHex) {
        const startKey = startHex.toString();
        const stack = this.board.get(startKey);
        if (!stack || stack.length > 1) return true; 

        const movingPiece = stack.pop();
        if (stack.length === 0) this.board.delete(startKey);

        let connected = true;
        const occupied = this.getAllOccupiedHexes();
        if (occupied.length > 1) {
            const visited = new Set();
            const queue = [occupied[0]];
            visited.add(occupied[0].toString());
            let count = 0;
            while (queue.length) {
                const c = queue.shift();
                count++;
                getNeighbors(c).forEach(n => {
                    if (this.board.has(n.toString()) && !visited.has(n.toString())) {
                        visited.add(n.toString());
                        queue.push(n);
                    }
                });
            }
            if (count !== occupied.length) connected = false;
        }

        if (!this.board.has(startKey)) this.board.set(startKey, []);
        this.board.get(startKey).push(movingPiece);
        return connected;
    }

    isConnectedAfterMove(startHex, destHex) {
        const startKey = startHex.toString();
        const destKey = destHex.toString();
        const sStack = this.board.get(startKey);
        if (!sStack) return false;
        
        const moving = sStack.pop();
        const startWasRemoved = (sStack.length === 0);
        if (startWasRemoved) this.board.delete(startKey);

        if (!this.board.has(destKey)) this.board.set(destKey, []);
        this.board.get(destKey).push(moving);

        const occupied = this.getAllOccupiedHexes();
        let connected = true;
        if (occupied.length > 1) {
            const visited = new Set();
            const queue = [occupied[0]];
            visited.add(occupied[0].toString());
            let count = 0;
            while (queue.length) {
                const c = queue.shift();
                count++;
                getNeighbors(c).forEach(n => {
                    if (this.board.has(n.toString()) && !visited.has(n.toString())) {
                        visited.add(n.toString());
                        queue.push(n);
                    }
                });
            }
            if (count !== occupied.length) connected = false;
        }

        this.board.get(destKey).pop();
        if (this.board.get(destKey).length === 0) this.board.delete(destKey);
        if (!this.board.has(startKey)) this.board.set(startKey, []);
        this.board.get(startKey).push(moving);

        return connected;
    }

    getPieceMoves(hex) {
        const top = this.getTopPiece(hex);
        if (!top || top.color !== this.turn) return [];
        if (!this.checkOneHive(hex)) return [];

        let moves = [];
        let abilities = [top.type];

        if (top.type === PIECES.OCTOPUS) {
            abilities = [];
            getNeighbors(hex).forEach(n => {
                const np = this.getTopPiece(n);
                if (np && np.type !== PIECES.OCTOPUS && np.type !== PIECES.ROCK) abilities.push(np.type);
            });
            abilities = [...new Set(abilities)];
        }

        this.liftTargets = [];

        abilities.forEach(type => {
            if (type === PIECES.CRAB || type === PIECES.LOBSTER) moves.push(...this.getSlideMoves(hex, 1));
            if (type === PIECES.SHRIMP) moves.push(...this.getShrimpMoves(hex));
            if (type === PIECES.SHARK) moves.push(...this.getSlideMoves(hex, 99));
            if (type === PIECES.DOLPHIN) moves.push(...this.getJumpMoves(hex));
            if (type === PIECES.STARFISH) {
                moves.push(...this.getSlideMoves(hex, 1));
                moves.push(...this.getClimbMoves(hex));
            }
            if (type === PIECES.DUCK) moves.push(...this.getDuckMoves(hex));

            if (type === PIECES.LOBSTER) {
                getNeighbors(hex).forEach(n => {
                    if (this.board.has(n.toString()) && this.checkOneHive(n)) this.liftTargets.push(n);
                });
            }
        });

        const seen = new Set();
        return moves.filter(m => !seen.has(m.toString()) && seen.add(m.toString()));
    }

    getSlideMoves(hex, range) {
        const moves = [];
        const queue = [{h: hex, dist: 0}];
        const visited = new Set([hex.toString()]);
        let head = 0;

        while(head < queue.length) {
            const {h, dist} = queue[head++];
            if (dist >= range) continue;

            getNeighbors(h).forEach(n => {
                if (this.board.has(n.toString())) return;
                const n_neigh = getNeighbors(n);
                const hasSupport = n_neigh.some(nn => !nn.equals(h) && this.board.has(nn.toString()));
                if (!hasSupport) return;

                const common = getNeighbors(h).filter(hn => n_neigh.some(nn => nn.equals(hn)));
                const blocked = common.filter(c => this.board.has(c.toString())).length;
                if (blocked < 2 && !visited.has(n.toString())) {
                    if (this.isConnectedAfterMove(hex, n)) {
                        visited.add(n.toString());
                        moves.push(n);
                        queue.push({h: n, dist: dist + 1});
                    }
                }
            });
        }
        return moves;
    }

    getShrimpMoves(startHex) {
        const validEnds = new Set();
        const isOccupied = (h) => this.board.has(h.toString());

        const findPath = (curr, depth, path) => {
            if (depth === 3) {
                if (!curr.equals(startHex) && this.isConnectedAfterMove(startHex, curr)) {
                    validEnds.add(curr.toString());
                }
                return;
            }

            getNeighbors(curr).forEach(next => {
                if (isOccupied(next.toString()) || path.some(p => p.equals(next))) return;

                const common = getNeighbors(curr).filter(cn => getNeighbors(next).some(nn => nn.equals(cn)));
                if (common.filter(c => isOccupied(c.toString())).length >= 2) return;

                const nextN = getNeighbors(next);
                if (!nextN.some(nn => isOccupied(nn.toString()))) return;

                const shared = nextN.filter(nn => isOccupied(nn.toString()) && getNeighbors(curr).some(cn => cn.equals(nn)));
                if (shared.length === 0) return;

                findPath(next, depth + 1, [...path, next]);
            });
        };
        findPath(startHex, 0, [startHex]);
        return Array.from(validEnds).map(s => Hex.fromString(s));
    }

    getDuckMoves(startHex) {
        const validEnds = [];
        const isOccupied = (h) => this.board.has(h.toString());

        const solve = (curr, depth, path) => {
            if (depth === 3) {
                if (!isOccupied(curr.toString()) && this.isConnectedAfterMove(startHex, curr)) {
                    validEnds.push(curr);
                }
                return;
            }

            getNeighbors(curr).forEach(next => {
                const nextOcc = isOccupied(next.toString());
                if (path.some(p => p.equals(next))) return;

                if (depth === 0) {
                    if (nextOcc) solve(next, 1, [...path, next]);
                } else if (depth === 1) {
                    if (nextOcc) solve(next, 2, [...path, next]);
                } else if (depth === 2) {
                    if (!nextOcc) {
                        const common = getNeighbors(curr).filter(cn => getNeighbors(next).some(nn => nn.equals(cn)));
                        const hCurr = this.getHeight(curr);
                        const blocked = common.filter(c => this.getHeight(c) > hCurr).length;
                        if (blocked < 2) solve(next, 3, [...path, next]);
                    }
                }
            });
        };

        solve(startHex, 0, [startHex]);
        const seen = new Set();
        return validEnds.filter(h => !seen.has(h.toString()) && seen.add(h.toString()));
    }

    getClimbMoves(hex) {
        const moves = [];
        getNeighbors(hex).forEach(n => {
            if (this.board.has(n.toString()) && this.isConnectedAfterMove(hex, n)) moves.push(n);
        });
        return moves;
    }

    getJumpMoves(hex) {
        const moves = [];
        DIRECTIONS.forEach(d => {
            let curr = hex.add(d);
            if (!this.board.has(curr.toString())) return;
            while(this.board.has(curr.toString())) curr = curr.add(d);
            if (this.isConnectedAfterMove(hex, curr)) moves.push(curr);
        });
        return moves;
    }

    getValidPlacements() {
        const valid = [];
        const occupied = this.getAllOccupiedHexes();
        const emptyAdj = new Set();
        occupied.forEach(h => getNeighbors(h).forEach(n => { if(!this.board.has(n.toString())) emptyAdj.add(n.toString()); }));

        emptyAdj.forEach(key => {
            const h = Hex.fromString(key);
            let badTouch = false;
            getNeighbors(h).forEach(n => {
                const s = this.getTopPiece(n);
                if (s && s.color !== this.turn && s.color !== 'neutral') badTouch = true;
            });
            if (!badTouch) valid.push(h);
        });
        return valid;
    }

    handleClick(rawX, rawY) {
        if (this.gameOver) return;
        const screenCX = this.canvas.width/2, screenCY = this.canvas.height/2;
        const worldX = (rawX - screenCX) / this.camera.zoom + this.camera.x;
        const worldY = (rawY - screenCY) / this.camera.zoom + this.camera.y;
        
        const hex = pixelToHex(worldX, worldY);
        const key = hex.toString();
        
        const inspector = document.getElementById('stack-inspector');
        const stackList = document.getElementById('stack-list');
        if (this.board.has(key)) {
            inspector.style.display = 'block';
            stackList.innerHTML = '';
            const stack = this.board.get(key).slice().reverse();
            stack.forEach((p, i) => {
                const row = document.createElement('div');
                row.className = 'stack-item';
                row.innerHTML = `<span class="stack-level">${stack.length - i}</span> <span style="font-size:1.2em">${PIECE_CONFIG[p.type].icon}</span> ${p.type} (${p.color})`;
                stackList.appendChild(row);
            });
        } else {
            inspector.style.display = 'none';
        }

        const moveMatch = this.validMoves.find(m => m.equals(hex));
        const liftMatch = this.liftTargets.find(m => m.equals(hex));

        if (moveMatch) {
            if (this.selectedHandPiece) this.placeFromHand(moveMatch);
            else if (this.selectedHex) this.moveOnBoard(moveMatch);
            return;
        }

        if (liftMatch && this.selectedHex) {
            this.executeLift(this.selectedHex, liftMatch);
            return;
        }

        const top = this.getTopPiece(hex);
        if (this.board.has(key) && top && top.color === this.turn) {
            this.selectedHandPiece = null;
            this.selectedHex = hex;
            this.validMoves = this.getPieceMoves(hex);
            this.updateUI();
        } else {
            this.selectedHex = null;
            this.selectedHandPiece = null;
            this.validMoves = [];
            this.liftTargets = [];
            this.updateUI();
        }
    }

    placeFromHand(target) {
        this.placePiece(target, this.selectedHandPiece, this.turn);
        this.hands[this.turn][this.selectedHandPiece]--;
        this.switchTurn();
    }

    moveOnBoard(target) {
        const stack = this.board.get(this.selectedHex.toString());
        const piece = stack.pop();
        if (stack.length === 0) this.board.delete(this.selectedHex.toString());
        this.placePiece(target, piece.type, piece.color);
        this.switchTurn();
    }

    executeLift(lobsterHex, sourceHex) {
        const sStack = this.board.get(sourceHex.toString());
        const lifted = sStack.pop();
        if (sStack.length === 0) this.board.delete(sourceHex.toString());
        this.board.get(lobsterHex.toString()).push(lifted);
        this.switchTurn();
    }

    selectHandPiece(type) {
        if (this.gameOver) return;
        this.selectedHandPiece = type;
        this.selectedHex = null;
        this.validMoves = this.getValidPlacements();
        this.updateUI();
    }

    loop() {
        this.ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color');
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.save();
        this.ctx.translate(this.canvas.width/2, this.canvas.height/2);
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        this.ctx.translate(-this.camera.x, -this.camera.y);

        for (const [key, stack] of this.board) {
            const h = Hex.fromString(key);
            stack.forEach((p, i) => this.drawHex(h, p, i));
        }

        if (this.selectedHex) this.drawHighlight(this.selectedHex, '#e94560');
        this.validMoves.forEach(m => this.drawHighlight(m, '#4cd137'));
        this.liftTargets.forEach(m => this.drawHighlight(m, '#ffd166'));

        this.ctx.restore();
        requestAnimationFrame(() => this.loop());
    }

    drawHex(hex, piece, height) {
        const {x, y} = hexToPixel(hex);
        const offsetY = height * -8;
        this.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const rad = Math.PI / 180 * (60 * i);
            const px = x + (HEX_SIZE - 2) * Math.cos(rad);
            const py = y + offsetY + (HEX_SIZE - 2) * Math.sin(rad);
            if (i===0) this.ctx.moveTo(px, py); else this.ctx.lineTo(px, py);
        }
        this.ctx.closePath();
        this.ctx.fillStyle = piece.color === 'white' ? '#e0e0e0' : (piece.color === 'black' ? '#2d3436' : '#636e72');
        this.ctx.fill();
        this.ctx.lineWidth = 1;
        this.ctx.strokeStyle = '#111';
        this.ctx.stroke();
        this.ctx.fillStyle = PIECE_CONFIG[piece.type].color;
        this.ctx.font = '22px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(PIECE_CONFIG[piece.type].icon, x, y + offsetY);
    }

    drawHighlight(hex, color) {
        const h = this.getHeight(hex) - (this.board.has(hex.toString()) ? 1 : 0);
        const {x, y} = hexToPixel(hex);
        const offsetY = h * -8;
        this.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const rad = Math.PI / 180 * (60 * i);
            const px = x + (HEX_SIZE - 4) * Math.cos(rad);
            const py = y + offsetY + (HEX_SIZE - 4) * Math.sin(rad);
            if (i===0) this.ctx.moveTo(px, py); else this.ctx.lineTo(px, py);
        }
        this.ctx.closePath();
        this.ctx.lineWidth = 4;
        this.ctx.strokeStyle = color;
        this.ctx.stroke();
    }

    updateUI() {
        document.getElementById('turn-indicator').innerText = this.turn.toUpperCase();
        const container = document.getElementById('hand-container');
        container.innerHTML = '';
        for (const [type, count] of Object.entries(this.hands[this.turn])) {
            if (count > 0) {
                const div = document.createElement('div');
                div.className = 'hand-piece' + (this.selectedHandPiece === type ? ' selected' : '');
                div.innerHTML = `<div class="piece-icon">${PIECE_CONFIG[type].icon}</div><div class="piece-name">${type}</div><div class="piece-count">${count}</div>`;
                div.onclick = (e) => { e.stopPropagation(); this.selectHandPiece(type); };
                container.appendChild(div);
            }
        }
    }

    getDistance(t1, t2) {
        return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
    }

    setupInputs() {
        window.addEventListener('resize', () => {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.updateUI();
        });
        window.dispatchEvent(new Event('resize'));

        this.canvas.addEventListener('wheel', e => {
            e.preventDefault();
            this.camera.zoom = Math.min(Math.max(this.camera.zoom - e.deltaY * 0.001, 0.4), 2.5);
        }, {passive:false});

        const start = (x, y) => { this.isDragging = false; this.lastMouse = {x, y}; };
        const move = (x, y) => {
            if (Math.abs(x - this.lastMouse.x) > 3 || Math.abs(y - this.lastMouse.y) > 3) this.isDragging = true;
            if (this.isDragging) {
                this.camera.x -= (x - this.lastMouse.x) / this.camera.zoom;
                this.camera.y -= (y - this.lastMouse.y) / this.camera.zoom;
                this.lastMouse = {x, y};
            }
        };
        const end = (x, y) => { if (!this.isDragging) this.handleClick(x, y); };

        this.canvas.addEventListener('mousedown', e => start(e.clientX, e.clientY));
        this.canvas.addEventListener('mousemove', e => { if(e.buttons) move(e.clientX, e.clientY); });
        this.canvas.addEventListener('mouseup', e => end(e.clientX, e.clientY));

        this.canvas.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                start(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                this.initialPinchDist = this.getDistance(e.touches[0], e.touches[1]);
                this.initialZoom = this.camera.zoom;
            }
        }, {passive:false});

        this.canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 1) {
                move(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2 && this.initialPinchDist !== null) {
                const currentDist = this.getDistance(e.touches[0], e.touches[1]);
                const scale = currentDist / this.initialPinchDist;
                this.camera.zoom = Math.min(Math.max(this.initialZoom * scale, 0.4), 2.5);
            }
        }, {passive:false});

        this.canvas.addEventListener('touchend', e => {
            if (e.touches.length < 2) this.initialPinchDist = null;
            if (e.changedTouches.length === 1 && e.touches.length === 0) end(this.lastMouse.x, this.lastMouse.y);
        });
    }
}
const game = new Game();
</script>
</body>
</html>